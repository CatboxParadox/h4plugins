I have code which sends multiple SSE events to a webpage. Somehow, somewhere the ACK is not getting back to the ESP and the default timeout action in AsyncEventSourceClient is to simply close the connection, which "breaks" the web interface as the javascript "errors" the connection.

I can see the actual ACK happening in wireshark so I don't think its a router / windows / browser bug, but after that...it's above my paygrade. The problem shows up with both ESP8266 (core 2.7.1/lwip2) and ESP32 (latest release), so it is possible that it is something to do with my network, or maybe a timing problem in ESPAsync TCP or even lwip. It also behaves exactly the same in Chrome and Firefox - I am still trying to track it down and welcome any suggestions for better methods to do that. Turning diagnostics or uncommenting them in ESPAsyncTCP makes everything run so slowly that pretty much everything else breaks (e.g. the web page + js cannot even get delivered to the browser :( ) so it doesn't help at all.

Of course it could be my code causing a timing problem, but I created a very simple MCVE using none of my code and while the "missing ACK" is admittedly very rare, it does still happen. I tried extending the ESPAsyncTCP _acktimeout from the default 5000 to 10000 and even 20000 and it shows that sometimes it's a "much longer than default" ack rather than a missing one but at those timeouts the queue fills up well before then anyway , so everything still breaks.

However I have seen occasions with very slow SSE message rate (or just one single message!) where the queue is not full and an ACK comes back in at 15+ seconds, clears the queue and of course everything carries on working. Unfortunately I don't have matching wireshark dump to show exactly when it was sent so I don't know what's causing the 15+ second trip time.

In the meawhile I have a "workaround" solution which will improve the resilience of the library in any event, even without this problem.

void AsyncEventSourceClient::_onTimeout(uint32_t time __attribute__((unused))){
//  _client->close(true); - Too harsh! breaks webui
    _messageQueue.remove(_messageQueue.front()); // much softer
    _runQueue(); // everything carries on working
}
My reasoning is as follows:

the message has actually been sent - all thats missing is the ACK
timeout can only ever be called if there is a unacked msg at head of queue so no error-checking is required
without this, the queue just keeps growing till it breaks the limit, which - in my view - is not the best solution
it does no harm to any other code
it does not require any chages to user code either in the ESP or the web UI js

RFC 2616
8.2.1 Persistent Connections and Flow Control
HTTP/1.1 servers SHOULD maintain persistent connections and use TCP's flow control mechanisms to resolve temporary overloads, rather than terminating connections with the expectation that clients will retry. The latter technique can exacerbate network congestion.
